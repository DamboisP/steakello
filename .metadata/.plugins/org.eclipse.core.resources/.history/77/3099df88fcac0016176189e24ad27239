package model;


import model.Chip;

/** 
 * 
 * @author Steffi Baugnies
 * Groupe 8
 */
public class ChipPlacer {
	
	private int chipsToFlip[][] = new int[8][8];

	/**
	 * Méthode placeChip place le jeton du joueur
	 * si le placement choisi est legal/valide.
	 * @param chipArray : un tableau de jetons du plateau de jeu
	 * @param boardSize : la taille du plateau de jeu
	 * @param x : la position X du jeton à placer		
	 * @param y : la position Y du jeton à placer
	 * @param player : le joueur dont c'est actuellement le tour
	 * @return true si le placement est accepté, qu'il fait retourner des jetons
	 * false si le placement est refusé
	 */
	public boolean placeChip(Chip[][] chipArray,int boardSize, int x, int y, int player){
		if(checkPlacementValidity(chipArray, x, y, player)){
			if(checkForChipToFlip(chipArray, x, y, player)){
				chipArray[x][y].setSet(true);
				chipArray[x][y].setPlayer(player);
				return true;
			}
		}
		return false;
	}
	/**
	 * Méthode checkPlacementValidity vérifie s'il y a un jeton autour de la position choisie
	 * par le joueur pour éviter un placement au milieu de nulle part.
	 * @param chipArray : un tableau de jetons du plateau de jeu
	 * @param boardSize est la taille du plateau de jeu
	 * @param x : la position X du jeton dont on vérifie la validité
	 * @param y : la position Y du jeton dont on vérifie la validité
	 * @param player : le joueur dont qui tente de placer le jeton
	 * @return true si le jeton que le joueur essaye de placer est autour d'un (ou plusieurs) jetons du joueur adverse
	 * false si il n'y a aucuns jetons du joueur adverse autour de la position choisie
	 */
	public boolean checkPlacementValidity(Chip[][] chipArray, int x, int y, int player){

		if(x >= 0 && x <= chipArray.length && y >= 0 && y <= chipArray.length && !chipArray[x][y].isSet()){
			for(int i = 0; i < chipArray.length; i++){
				for(int j = 0; j < chipArray.length; j++){
					if(chipArray[i][j].isSet() && chipArray[i][j].getPlayer() != player){
						if((i == x+1 || i == x-1) && (j == y+1 || j == y-1)){
							return true;
						}
						else if((j == y+1 || j == y-1) && i == x){
							return true;
						}
						else if((i == x+1 || i == x-1) && j == y){
							return true;
						}


					}
				}
			}
			
		}
		return false;
	}
	
	
	/**
	 * Méthode checkForChipToFlip vérifie, dans chaque direction,
	 * s'il est possible de prendre/retourner certains jetons 
	 * appartenant à (de la couleur de) l'adversaire. 
	 * @param chipArray : un tableau de jetons du plateau de jeu
	 * @param x : la position X du jeton que le joueur veut placer
	 * @param y : la position Y du jeton que le joueur veut placer 
	 * @param player : le joueur dont c'est actuellement le tour
	 * @return true si il y a au moins un jeton adversaire à retourner
	 * false s'il n'y en a pas
	 */
	public boolean checkForChipToFlip(Chip[][] chipArray, int x, int y, int player){
		resetChipsToFlip();
		boolean capturedChip = false;
		for(int i = 0; i < chipArray.length; i++){
			for(int j = 0; j < chipArray.length; j++){
				//Vers la droite
				if(i == x+1 && j == y){
					int k = 0;
					while(chipArray[i+k][j].getPlayer() != player && (i+k) < chipArray.length - 1){
						chipsToFlip[i+k][j] = 1;
						k++;
					}
					if(chipArray[i+k][j].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers la gauche
				else if(i == x-1 && j == y){
					int k = 0;
					while(chipArray[i-k][j].getPlayer() != player && (i-k) > 1){
						
						chipsToFlip[i-k][j] = 1;
						k++;
					}
					if(chipArray[i-k][j].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers le haut
				else if(i == x && j == y - 1){
					int k = 0;
					while(chipArray[i][j-k].getPlayer() != player && (j-k) > 1){
						
						chipsToFlip[i][j-k] = 1;
						k++;
					}
					if(chipArray[i][j-k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers le bas
				else if(i == x && j == y + 1){
					int k = 0;
					while(chipArray[i][j+k].getPlayer() != player && (j+k) < chipArray.length - 1){
						
						chipsToFlip[i][j+k] = 1;
						k++;
					}
					if(chipArray[i][j+k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers bas droite
				if(i == x+1 && j == y+1){
					int k = 0;
					while(chipArray[i+k][j+k].getPlayer() != player && (i+k) < chipArray.length - 1 && (j+k) < chipArray.length - 1){
						chipsToFlip[i+k][j+k] = 1;
						k++;
					}
					if(chipArray[i+k][j+k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers bas gauche
				if(i == x-1 && j == y+1){
					int k = 0;
					while(chipArray[i-k][j+k].getPlayer() != player && (i-k) > 1 && (j+k) < chipArray.length - 1){
						chipsToFlip[i-k][j+k] = 1;
						k++;
					}
					if(chipArray[i-k][j+k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers haut droite
				if(i == x+1 && j == y-1){
					int k = 0;
					while(chipArray[i+k][j-k].getPlayer() != player && (i+k) < chipArray.length - 1 && (j-k) > 1){
						chipsToFlip[i+k][j-k] = 1;
						k++;
					}
					if(chipArray[i+k][j-k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//Vers haut gauche
				if(i == x-1 && j == y-1){
					int k = 0;
					while(chipArray[i-k][j-k].getPlayer() != player && (i-k) > 1 && (j-k) > 1){
						chipsToFlip[i-k][j-k] = 1;
						k++;
					}
					if(chipArray[i-k][j-k].getPlayer() != player){
						resetChipsToFlip();
					}
					else if(k == 0){
						resetChipsToFlip();
					}
					else{
						fillGameBoard(chipArray, player);
						capturedChip = true;
					}
				}
				//

			}
		}
		return capturedChip;
	}
	
	
	
	/**
	 * Méthode fillGameBoard retourne les jetons de l'adversaire
	 * sur base de la variable tampon
	 * qui a été remplie au péalable.
	 * @param chipArray : le tableau de jetons du plateau de jeu
	 * @param player : le joueur qui vient de jouer
	 */
	private void fillGameBoard(Chip[][] chipArray, int player){
		for(int i = 0; i < chipsToFlip.length; i++){
			for(int j = 0; j < chipsToFlip.length; j++){
				if(chipsToFlip[i][j] == 1){
						chipArray[i][j].setSet(true);
						chipArray[i][j].setPlayer(player);
				}
			}
		}
	}
	
	/**
	 * Méthode resetChipstoFlip 
	 * Rétablit la variable tampon des jetons à retourner.
	 */
	private void resetChipsToFlip(){
		for(int i = 0; i < chipsToFlip.length; i++){
			for(int j = 0; j < chipsToFlip.length; j++){
				chipsToFlip[i][j] = 0;
			}
		}
	}
	
}
